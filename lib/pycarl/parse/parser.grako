#@@whitespace :: /[\t ]+/
@@left_recursion :: False
@@keyword :: true false

# Lexer

@name
identifier = /(?!\d)[\w_]+/ ;

number = /\d+(\.\d+)?([eE][+-]?\d+)?/ ;

bool = 'true' | 'false' ;

# Rules

expression = @:formula $;

formula = @:iff_form;

iff_form = lhs:imp_form rhs:{'<->' ~ imp_form}* ;

imp_form = lhs:xor_form rhs:{'->' ~ xor_form}* ;

xor_form = lhs:or_form rhs:{'^' ~ or_form}* ;

or_form = lhs:and_form rhs:{'|' ~ and_form}* ;

and_form = lhs:constraint rhs:{'&' ~ constraint}* ;

constraint = @:eq_expr ;

# Constraints cannot be nested!
eq_expr = lhs:rel_expr rhs:[('==' | '!=' | '=') ~ numerical_expr] ;

rel_expr = lhs:numerical_expr rhs:[('<=' | '>=' | '<' | '>') ~ numerical_expr] ;

numerical_expr = @:add_expr ;

add_expr = lhs:scale_expr rhs:{('+' | '-') ~ scale_expr}*;

scale_expr =  lhs:pow_expr rhs:{('*' | '/') ~ pow_expr}*;

pow_expr = lhs:unary_expr [op:('**') rhs:pow_expr] ;

unary_expr = op:['+' | '-' | '~'] ~ rhs:atom ;

atom = '(' @:formula ')' | @:bool | @:number | @:identifier ;
